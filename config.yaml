# ============================================================
# SLAM Configuration
# ============================================================

# --- Data source ---
data_file: "data/test3lidar_trimmed.csv"

# --- IMU orientation (quaternion) ---
# When enabled the gyro-derived absolute yaw replaces the expensive rotation
# search, making turns virtually bulletproof.  The file must be semicolon-
# delimited with columns: timestamp_us ; qx ; qy ; qz ; qw
imu:
  enabled: true
  file: "data/test3imu_trimmed.csv"
  narrow_search_range: 5.0   # degrees — tiny refinement search around IMU yaw

# --- ICP parameters ---
# method: "point_to_line" (recommended for 2D) or "point_to_point" (classic)
icp:
  method: "point_to_line"
  normal_k: 10                  # neighbours for normal estimation (point_to_line only)
  voxel_size: 0.06
  error_threshold: 1.0e-10
  max_iterations: 100
  error_reject_threshold: 0.25  # skip scan if ICP error > this value

# --- Pre-alignment (handles large inter-scan rotations) ---
# method: "rotation_search" | "features" | "both" | "none"
#   rotation_search — brute-force tries every angle, most robust
#   features        — curvature keypoints + RANSAC (fast, less robust)
#   both            — rotation search first, features to refine
#   none            — no pre-alignment (vanilla ICP only)
features:
  method: "rotation_search"

  # ─ correlative rotation search ─
  rotation_voxel_size: 0.2   # coarse voxel for the angle sweep (meters)
  angle_step_coarse: 2.0      # degrees per step in the full [-180°,180°) sweep
  angle_step_fine: 0.2        # degrees per step in the refinement band

  # ─ feature-based alignment (used when method is "features" or "both") ─
  voxel_size: 0.2       # coarse downsample for feature extraction (meters)
  k_curvature: 10       # neighbours used for curvature estimation
  top_n: 100            # max keypoints per scan
  min_kp_dist: 0.3      # non-max suppression radius (meters)
  k_descriptor: 30      # neighbours for sorted-distance descriptor
  ratio_threshold: 0.8  # Lowe's ratio test for descriptor matching
  ransac_iterations: 1000
  inlier_threshold: 0.5 # RANSAC inlier distance (meters)
  min_inliers: 3        # minimum inliers to accept alignment (else fall back to identity)

# --- Scan-to-submap matching (reduces drift, especially during turns) ---
# Instead of aligning each scan to only the previous scan, we align against
# a rolling window of recent scans projected into the global frame.
# Uses point-to-point ICP (not point-to-line) because normals from merged
# multi-scan data have inconsistent sign that corrupts the point-to-line solver.
submap:
  enabled: true           # false = fall back to scan-to-scan ICP
  size: 30                # recent scans in the submap (more = more robust during turns)
  voxel_size: 0.06        # downsample density for the submap (≥ icp.voxel_size)
  max_corr_dist: 2.0      # metres — reject correspondences farther than this (needs slack for submap drift)
  rotation_range: 90.0    # degrees — search ± this range around predicted rotation (catches aggressive turns)
  rotation_step: 1.0      # degrees — coarse step for rotation search (finer = more accurate)
  rotation_fine_step: 0.2  # degrees — fine sweep step (sub-degree precision)
  rotation_voxel_size: 0.25  # coarse voxel for rotation search scoring (speed)

# --- Loop closure & pose graph optimisation ---
loop_closure:
  enabled: true
  distance_threshold: 0.5       # metres — consider closure if estimated poses are this close
  min_interval: 50             # minimum scan gap (high enough to skip same-path segment)
  min_cumulative_travel: 2.0   # metres — vehicle must have driven at least this far along the
                                # trajectory since the candidate scan (prevents false closures
                                # when the robot is still near the start and hasn't left yet)
  max_candidates: 3             # try up to N candidates per scan
  error_threshold: 0.2          # max ICP error to accept a loop closure (higher than sequential!)
  optimization_iterations: 20   # Gauss-Newton iterations
  information_scale: 1.0        # weight multiplier for loop-closure edges vs odometry

# --- Point cloud filter (z-slice before flattening to 2D) ---
filter:
  z_min: 0.0    # meters – discard points below this height
  z_max: 2.0    # meters – discard points above this height

# --- Occupancy grid / mapping ---
mapping:
  resolution: 0.1     # meters per cell
  margin: 50.0        # meters of padding around first scan bounds
  p_hit: 0.9          # probability update for occupied cells (higher = harder to erase)
  p_miss: 0.45        # probability update for free (ray) cells (closer to 0.5 = weaker free updates)
  log_odds_min: -10.0  # clamp lower bound (larger range = more permanence)
  log_odds_max: 10.0   # clamp upper bound

# --- Lidar service ---
service:
  sleep_s: 0.0        # delay between scans (seconds), 0 = as fast as possible
  loop: true           # restart file when end is reached

# --- Run control ---
num_scans: null        # null = unlimited, or set an integer to limit
process_every_n: 1     # process every Nth scan (2 = skip every other, 3 = every third, etc.)

# --- Live map display ---
display:
  live_map: true
  window_width: 1400
  window_height: 1000
  cmap: "gray"
  clim_min: 0.0
  clim_max: 1.0
  background: "black"
  trajectory_color: "cyan"
  pose_color: "lime"
  pose_size: 12

# --- Output files ---
output:
  csv: "tmp/occupancy_grid.csv"
  npy: "tmp/occupancy_grid.npy"
